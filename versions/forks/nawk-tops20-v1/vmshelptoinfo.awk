# -*-awk-*-
# <BEEBE.EMACS>VMSHELPTOINFO.AWK.2, 24-Jan-87 13:58:41, Edit by BEEBE
#
# Adapted from TOPS-20 EMACS TECO  M-X UHELP to INFO Conversion  written
# by Nelson H.F. Beebe (BEEBE@UTAH-SCIENCE).
#
# Convert the file from VAX VMS HELP format to INFO format on stdout:
#
#         awk -f VMSHELPtoINFO.awk foo.hlp >foo.info
#         itags foo.info
#
# The ITAGS program builds a special tag table at the end of the file to
# facilitate fast searching.
#
# A VMS HELP  file consists of  text blocks beginning  with a least  one
# blank or tab (actually any character which is a delimiter according to
# the current syntax table will do), prefixed by a header line beginning
# in column 1.  The first character in  the header line is a node  level
# number, which must be in  the range 1 ..  9.  Any lines preceding  the
# first header  line  will be  prefixed  to  the Top  level  menu  node.
# Trailing blanks are discarded from the output lines.
#
# For example, here is a VMS HELP file, foo.hlp
#
#  0:1 This is prefix material which belongs in the Top menu node.
# 1 FIRST
#  1:1 first body
# 2 FIRST.FIRSTCHILD
#  2:1 first child
# 2 FIRST.SECONDCHILD
#  2:1 second child
#  2:2 second child
# 2 FIRST.THIRDCHILD
#  2:1 third child
#  2:2 third child
#  2:3 third child
# 1 SECOND
#  1:1 This node has its own menu:
# * Menu:
#
# * TeX: (TEX)
# * DVI: (DVI)
# * FOO: (BEM:FOO)
# * NODE: (BEM:FOO)FIRST
#
# and here is the result of awk and itags processing:
#
# -*-Text-*-
# ***WARNING***:  Do NOT edit this file.  It was created automatically from
# the corresponding .HLP file
#         vms.hlp
# by the VMSHELPtoINFO.awk program
# ^_^L
# File: vms, Node: FIRST.FIRSTCHILD, Previous: FIRST, Up: FIRST, Next: FIRST.SECONDCHILD
# FIRST.FIRSTCHILD
#  2:1 first child
# ^_^L
# File: vms, Node: FIRST.SECONDCHILD, Previous: FIRST.FIRSTCHILD, Up: FIRST, Next: FIRST.THIRDCHILD
# FIRST.SECONDCHILD
#  2:1 second child
#  2:2 second child
# ^_^L
# File: vms, Node: FIRST.THIRDCHILD, Previous: FIRST.SECONDCHILD, Up: FIRST, Next: FIRST
# FIRST.THIRDCHILD
#  2:1 third child
#  2:2 third child
#  2:3 third child
# ^_^L
# File: vms, Node: FIRST, Previous: Top, Up: Top, Next: SECOND
# FIRST
#  1:1 first body
#
# * Menu:
#
# * FIRST.FIRSTCHILD::
# * FIRST.SECONDCHILD::
# * FIRST.THIRDCHILD::
# ^_^L
# File: vms, Node: SECOND, Previous: FIRST, Up: Top, Next: Top
# SECOND
#  1:1 This node has its own menu:
# * Menu:
#
# * TeX: (TEX)
# * DVI: (DVI)
# * FOO: (BEM:FOO)
# * NODE: (BEM:FOO)FIRST
# ^_^L
# File: vms, Node: Top, Previous: SECOND, Up: (CLSC), Next: FIRST
#  0:1 This is prefix material which belongs in the Top menu node.
#
# * Menu:
#
# * FIRST::
# * SECOND::
# ^_^L
# Tag Table:
# File: vms, Node: FIRST.FIRSTCHILD^?193
# File: vms, Node: FIRST.SECONDCHILD^?322
# File: vms, Node: FIRST.THIRDCHILD^?481
# File: vms, Node: FIRST^?634
# File: vms, Node: SECOND^?805
# File: vms, Node: Top^?991
# ^_
# End Tag Table
#
# Although INFO files normally  have the menu node  at the top, this  is
# inconvenient for one-pass  processing, so  we collect  menu items  and
# output them after the last child node.  Thanks to the wonders of  awk,
# this is quite a  simple program.  The basic  idea is to identify  node
# header lines and  output any  previous node, and  otherwise to  simply
# append the input line to the current body.
#
# The name  of the  command line  should be  a full  path  specification
# (either TOPS-20 or Unix), since it is desirable to record this in  the
# output so we know where the .INFO file came from.  It would be nice to
# get the current date/time  and the file date/time  too, but it is  not
# clear how to do this except on a Unix host.
#
# The tree structure established in the .INFO file also contains a ring,
# so that we have
#
#                         |--------Top--------|
#                         |                   |
#                         A--B--C--D--E--...--Z
#
# That is, the first subnode A has Top as its Previous, and the last, Z,
# has Top as  its Next.  This  is reasonable, and  avoids an INFO  error
# message "No next (previous) node"  if A and Z  are not so linked.   An
# alternative way would be  to link A  to Z, but  then the reader  could
# cycle indefinitely, instead of arriving back at the Top after a series
# of N (Next) commands.  However, for child nodes containing menus,  the
# childs Next and Previous links point to its siblings, not to the first
# and last entries in its menu.
#
# Any lines preceding the  first node header line  are prepended to  the
# Top menu node.  That is how introductory material gets into the  file.
# Nodes may also have their own  Menus; these have lines beginning  with
# an asterisk, which are considered part of the body.  For example
#
# 3 NODENAME
#  blah blah blah
# * Menu:
# * item-1::			description
# * item-2: (infofile)		description
# 3 NEXTNODENAME
#  blah blah blah
#
# Note: The original awk  program available on most  Unix systems has  a
# nuisance  restriction  that   array  subscripts  may   not  be   zero.
# Consequently, the level numbers referred to below are biased by 1 from
# their input values so as to ensure that all subscripts are larger than
# 0.  This restriction is removed in the June 5, 1985 research awk  from
# AT&T Bell Laboratories in Murray Hill.
#
# [24-Jan-87]

BEGIN	{
	level = 1;		# tree root (Top node) is at level 1
	MenuTag = "\n* Menu:\n\n";
	NodeTag = "\n";	# "\037\f\n" doesn't work, sigh...

	Body[1] = "";
	Menu[1] = "";
	Node[1] = "Top";
	Up[1] = "(VMSHELP)"	# maybe (DIR) or (LOCAL) at your site

	File = FILENAME;	# dev:<dir>name.ext OR /dir/dir/../name.ext

	k = index(File,":");
	if (k > 0)		# trim TOPS-20 or VAX VMS device
	    File = substr(File,k+1,length(File)-k);

	k = index(File,">");
	if (k > 0)		# trim TOPS-20 directory
	    File = substr(File,k+1,length(File)-k);

	k = index(File,"]");
	if (k > 0)		# trim VAX VMS directory
	    File = substr(File,k+1,length(File)-k);

	k = index(File,"/");
	while (k > 0)		# trim Unix path
	{
	    File = substr(File,k+1,length(File)-k);
	    k = index(File,"/");
	}

	k = index(File,".");
	if (k > 0) File = substr(File,1,k-1);	# trim extension

	print "-*-Text-*-"
	print "***WARNING***:  Do NOT edit this file.  It was created automatically from"
	print "the corresponding .HLP file"
	print "\t" FILENAME;
	print "by the VMSHELPtoINFO.awk program"
    }

# Main processing loop begins here
{
    Line = $0;

    len = k = length(Line);
    while ((k > 0) && (substr(Line,k,1) == " "))
	k--;
    if (len > k)		# efficiency--don't copy blank-trimmed lines
	Line = substr(Line,1,k);

    if ((length(Line) > 0) && (substr(Line,1,1) != " ") && (substr(Line,1,1) != "*"))
    {				# new node
	new_level = substr(Line,1,1) + 1;
	if (new_level < 2)
	{
	    print "?Illegal level number < 1";
	    print " At line >>> " Line "<<<";
	    exit;
	}
	Line = substr(Line,3,length(Line)-2);	# strip level number
	if (new_level > level)		# descending into child node
	{
	    if (new_level != (level + 1))
	    {
	        print "?Increased level number MUST be old level + 1";
		print " At line>>> " Line "<<<";
		exit;
	    }
	    Up[new_level] = Node[level];
	    Previous[new_level] = Up[new_level]; # first child node points to parent
	    Next[level] = Line;	# parent points to first child
	    level = new_level;
	}
	else if (new_level == level)	# sibling node at same level
	{
	    Next[level] = Line;
	    printf "%sFile: %s, Node: %s, Previous: %s, Up: %s, Next: %s\n%s",\
		NodeTag, File, Node[level], Previous[level], Up[level], Next[level],\
		Body[level];
	    Previous[level] = Node[level];
	}
	else		# (new_level < level) -- ascending to parent node
	{
	    for (k = level; k >= new_level; --k)
	    {		# output child nodes in ascending order, then last parent node
	        if (k > new_level)	# last child node points to parent
		    Next[k] = Up[k];
		else		# last sibling points to new node
		    Next[k] = Line;
	        printf "%sFile: %s, Node: %s, Previous: %s, Up: %s, Next: %s\n%s%s",\
	            NodeTag, File, Node[k], Previous[k], \
		    Up[k], Next[k], Body[k], Menu[k];
	    }
	    level = new_level;
	    Previous[level] = Node[level];
	}
	Menu[level] = "";
	Node[level] = Line;
	Body[level] = Line "\n";
	if (Menu[level-1] == "") Menu[level-1] = MenuTag;
	Menu[level-1] = Menu[level-1] "* " Node[level] "::\n";
    }
    else			# not node name, just accumulate body line
	Body[level] = Body[level] Line "\n";
}

END {
	Next[level] = Up[level];	# last child points to parent
	Previous[1] = Node[2];

	new_level = 1;		# returning to Top node
	for (k = level; k >= new_level ; k = k - 1)
	{	# output child nodes in ascending order, then last parent node
	    if (k > new_level)	# last child node points to parent
	        Next[k] = Up[k];
	    printf "%sFile: %s, Node: %s, Previous: %s, Up: %s, Next: %s\n%s%s",\
	        NodeTag, File, Node[k], Previous[k], Up[k], \
		Next[k], Body[k], Menu[k];
	}
# No tag table for GNU EMACS
#	printf "%sTag Table:\n\nEnd Tag Table\n",NodeTag;
    }
